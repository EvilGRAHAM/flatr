lung_cancer_ct %>%
flatten_ct() %>%
glm(
Lung ~ City + Smoking
,family = binomial
,data = .
) %>% goodness_of_fit(response = "Lung")
goodness_of_fit(lung_logit, response = "Lung")
glm(lung_tidy$Lung ~ lung_tidy$Smoking + lung_tidy$City, family = binomial)
glm(lung_tidy$Lung ~ lung_tidy$Smoking + lung_tidy$City, family = binomial)$data
lung_logit2 <- glm(lung_tidy$Lung ~ lung_tidy$Smoking + lung_tidy$City, family = binomial)$data
goodness_of_fit(lung_logit2, response = "Lung")
goodness_of_fit(lung_logit2, response = "Lung", data = lung_tidy)
is.null(lung_logit2$data)
goodness_of_fit <- function(model, ..., response, type = "Chisq"){
# This function is designed to only work with contingency tables in the form of an array.
#
if(!is.null(model$data)){
data <- model$data
}
# If the inputed data is not an array, the function is exited, and an error message is displayed.
if(!is.data.frame(data)){
stop("Please enter a data frame")
} else{
# Number of combinations of the response variable - number of parameters in the model
df <-
(data %>%
select(-matches(response)) %>%
unique() %>%
tally() %>%
as.numeric()) - length(coef(model))
# Creates a data frame where the response column is converted into integers 0, 1, ...
data_response <-
data %>%
transmute_at(
vars(matches(response))
,unclass
) %>%
select(Response_Num = matches(response)) %>%
transmute(Response_Num = Response_Num - 1)
data_summary <-
data %>%
ungroup() %>%
# Combines the data with integer version of the Response
cbind(data_response) %>%
as_tibble() %>%
group_by_at(
vars(
colnames(data)[colnames(data) != response]
)
) %>%
# Summarizes by the 2 explanatory variables, and then finds the number of entries for each level of the Response
summarize(
Response_0 = sum(Response_Num)
,Response_1 = length(Response_Num) - Response_0
,Total = Response_1 + Response_0
) %>%
ungroup()
response_n_cols <- c("n", response)
data_out <-
data_summary %>%
cbind(
phat =
predict(
object = model
,newdata = data_summary
,type = "response"
)
) %>%
as_tibble() %>%
mutate(
Expected_0 = phat * Total
,Expected_1 = (1 - phat) * Total
)
if(type == "Chisq"){
data_out <-
data_out %>%
mutate(
ChiSq_0 = (Response_0 - Expected_0)^2 / Expected_0
,ChiSq_1 = (Response_1 - Expected_1)^2 / Expected_1
) %>%
select(
ChiSq_0
,ChiSq_1
) %>%
sum()
} else if(type == "Gsq"){
data_out <-
data_out %>%
mutate(
GSq_0 = 2 * Response_0 * log(Response_0 / Expected_0)
,GSq_1 = 2 * Response_1 * log(Response_1 / Expected_1)
) %>%
select(
GSq_0
,GSq_1
) %>%
sum()
} else{
stop("Please enter a valid test.")
}
return(list(data_out, pchisq(q = data_out, df = df, lower.tail = FALSE)))
}
}
goodness_of_fit(lung_logit2, response = "Lung", data = lung_tidy)
goodness_of_fit <- function(model, ..., data,response, type = "Chisq"){
# This function is designed to only work with contingency tables in the form of an array.
#
if(!is.null(model$data)){
data <- model$data
}
# If the inputed data is not an array, the function is exited, and an error message is displayed.
if(!is.data.frame(data)){
stop("Please enter a data frame")
} else{
# Number of combinations of the response variable - number of parameters in the model
df <-
(data %>%
select(-matches(response)) %>%
unique() %>%
tally() %>%
as.numeric()) - length(coef(model))
# Creates a data frame where the response column is converted into integers 0, 1, ...
data_response <-
data %>%
transmute_at(
vars(matches(response))
,unclass
) %>%
select(Response_Num = matches(response)) %>%
transmute(Response_Num = Response_Num - 1)
data_summary <-
data %>%
ungroup() %>%
# Combines the data with integer version of the Response
cbind(data_response) %>%
as_tibble() %>%
group_by_at(
vars(
colnames(data)[colnames(data) != response]
)
) %>%
# Summarizes by the 2 explanatory variables, and then finds the number of entries for each level of the Response
summarize(
Response_0 = sum(Response_Num)
,Response_1 = length(Response_Num) - Response_0
,Total = Response_1 + Response_0
) %>%
ungroup()
response_n_cols <- c("n", response)
data_out <-
data_summary %>%
cbind(
phat =
predict(
object = model
,newdata = data_summary
,type = "response"
)
) %>%
as_tibble() %>%
mutate(
Expected_0 = phat * Total
,Expected_1 = (1 - phat) * Total
)
if(type == "Chisq"){
data_out <-
data_out %>%
mutate(
ChiSq_0 = (Response_0 - Expected_0)^2 / Expected_0
,ChiSq_1 = (Response_1 - Expected_1)^2 / Expected_1
) %>%
select(
ChiSq_0
,ChiSq_1
) %>%
sum()
} else if(type == "Gsq"){
data_out <-
data_out %>%
mutate(
GSq_0 = 2 * Response_0 * log(Response_0 / Expected_0)
,GSq_1 = 2 * Response_1 * log(Response_1 / Expected_1)
) %>%
select(
GSq_0
,GSq_1
) %>%
sum()
} else{
stop("Please enter a valid test.")
}
return(list(data_out, pchisq(q = data_out, df = df, lower.tail = FALSE)))
}
}
goodness_of_fit(lung_logit2, response = "Lung", data = lung_tidy)
predict(lung_logit2)
predict(lung_logit2, data = lung_tidy)
predict(lung_logit2, data = lung_tidy %>% select(City, Smoking))
predict(lung_logit2, data = lung_tidy %>% select(City, Smoking), type = "response")
predict(lung_logit, data = lung_tidy %>% select(City, Smoking), type = "response")
predict(lung_logit, data = lung_tidy, type = "response")
predict(lung_logit, type = "response")
predict
goodness_of_fit <- function(model, ..., data, response, type = "Chisq"){
# This function is designed to only work with contingency tables in the form of an array.
#
if(!is.null(model$data)){
data <- model$data
}
# If the inputed data is not an array, the function is exited, and an error message is displayed.
if(!is.data.frame(data)){
stop("Please enter a data frame")
} else{
# Number of combinations of the response variable - number of parameters in the model
df <-
(data %>%
select(-matches(response)) %>%
unique() %>%
tally() %>%
as.numeric()) - length(coef(model))
# Creates a data frame where the response column is converted into integers 0, 1, ...
data_response <-
data %>%
transmute_at(
vars(matches(response))
,unclass
) %>%
select(Response_Num = matches(response)) %>%
transmute(Response_Num = Response_Num - 1)
data_summary <-
data %>%
ungroup() %>%
# Combines the data with integer version of the Response
cbind(data_response) %>%
as_tibble() %>%
group_by_at(
vars(
colnames(data)[colnames(data) != response]
)
) %>%
# Summarizes by the 2 explanatory variables, and then finds the number of entries for each level of the Response
summarize(
Response_0 = sum(Response_Num)
,Response_1 = length(Response_Num) - Response_0
,Total = Response_1 + Response_0
) %>%
ungroup()
response_n_cols <- c("n", response)
data_out <-
data_summary %>%
cbind(
phat =
predict(
object = model
,newdata = data_summary
,type = "response"
)
) %>%
as_tibble() %>%
mutate(
Expected_0 = phat * Total
,Expected_1 = (1 - phat) * Total
)
if(type == "Chisq"){
data_out <-
data_out %>%
mutate(
ChiSq_0 = (Response_0 - Expected_0)^2 / Expected_0
,ChiSq_1 = (Response_1 - Expected_1)^2 / Expected_1
) %>%
select(
ChiSq_0
,ChiSq_1
) %>%
sum()
} else if(type == "Gsq"){
data_out <-
data_out %>%
mutate(
GSq_0 = 2 * Response_0 * log(Response_0 / Expected_0)
,GSq_1 = 2 * Response_1 * log(Response_1 / Expected_1)
) %>%
select(
GSq_0
,GSq_1
) %>%
sum()
} else{
stop("Please enter a valid test.")
}
return(list(data_out, pchisq(q = data_out, df = df, lower.tail = FALSE)))
}
}
predict(lung_logit2, newdata = lung_tidy, type = "response")
predict(lung_logit, newdata = lung_tidy %>% select(City, Smoking), type = "response")
predict(lung_logit1, newdata = lung_tidy %>% select(City, Smoking), type = "response")
predict(lung_logit2, newdata = lung_tidy %>% select(City, Smoking), type = "response")
predict.glm(lung_logit2, newdata = lung_tidy %>% select(City, Smoking), type = "response")
predict.glm(lung_logit, newdata = lung_tidy %>% select(City, Smoking), type = "response")
predict.glm(lung_logit2, newdata = lung_tidy %>% select(City, Smoking), type = "response")
predict.glm(lung_logit2, newdata = lung_tidy, type = "response")
predict.glm(lung_logit2, type = "response")
predict.glm(lung_logit2, newdata = data.frame(Smoking = c("Y"), City = c("Beij")), type = "response")
predict(lung_logit2, newdata = data.frame(Smoking = c("Y"), City = c("Beij")), type = "response")
data.frame(Smoking = c("Y"), City = c("Beij"))
data.frame(Smoking = as.factor(c("Y")), City = as.factor(c("Beij")))
predict(lung_logit2, newdata = data.frame(Smoking = as.factor(c("Y")), City = as.factor(c("Beij"))), type = "response")
summary(lung_logit2)
lung_logit2
lung_logit2 <- glm(lung_tidy$Lung ~ lung_tidy$Smoking+lung_tidy$City, family = binomial)
summary(lung_logit2)
predict(lung_logit2, newdata = data.frame(Smoking = as.factor(c("Y")), City = as.factor(c("Beij"))), type = "response")
lung_logit2$data
lung_logit2
lung_logit2$data
predict(lung_logit2, newdata = lung_summary, type = "response")
lung_summary
predict(lung_logit2, newdata = lung_summary)
predict(lung_logit2, newdata = lung_summary, type = "response")
predict.glm(object = lung_logit2, newdata = lung_summary)
predict.glm(object = lung_logit, newdata = lung_summary)
predict.glm(object = lung_logit2, newdata = lung_summary) %>% unique
predict.glm(object = lung_logit, newdata = lung_summary) %>% unique
goodness_of_fit <- function(model, ..., data, response, type = "Chisq"){
# This function is designed to only work with contingency tables in the form of an array.
#
if(!is.null(model$data)){
data <- model$data
}
# If the inputed data is not an array, the function is exited, and an error message is displayed.
if(!is.data.frame(data)){
stop("Please enter a data frame")
} else{
# Number of combinations of the response variable - number of parameters in the model
df <-
(data %>%
select(-matches(response)) %>%
unique() %>%
tally() %>%
as.numeric()) - length(coef(model))
# Creates a data frame where the response column is converted into integers 0, 1, ...
data_response <-
data %>%
transmute_at(
vars(matches(response))
,unclass
) %>%
select(Response_Num = matches(response)) %>%
transmute(Response_Num = Response_Num - 1)
data_summary <-
data %>%
ungroup() %>%
# Combines the data with integer version of the Response
cbind(data_response) %>%
as_tibble() %>%
group_by_at(
vars(
colnames(data)[colnames(data) != response]
)
) %>%
# Summarizes by the 2 explanatory variables, and then finds the number of entries for each level of the Response
summarize(
Response_0 = sum(Response_Num)
,Response_1 = length(Response_Num) - Response_0
,Total = Response_1 + Response_0
) %>%
ungroup()
response_n_cols <- c("n", response)
data_out <-
data_summary %>%
cbind(
phat =
predict(
object = model
,newdata = data_summary
,type = "response"
)
) %>%
as_tibble() %>%
mutate(
Expected_0 = phat * Total
,Expected_1 = (1 - phat) * Total
)
if(type == "Chisq"){
data_out <-
data_out %>%
mutate(
ChiSq_0 = (Response_0 - Expected_0)^2 / Expected_0
,ChiSq_1 = (Response_1 - Expected_1)^2 / Expected_1
) %>%
select(
ChiSq_0
,ChiSq_1
) %>%
sum()
} else if(type == "Gsq"){
data_out <-
data_out %>%
mutate(
GSq_0 = 2 * Response_0 * log(Response_0 / Expected_0)
,GSq_1 = 2 * Response_1 * log(Response_1 / Expected_1)
) %>%
select(
GSq_0
,GSq_1
) %>%
sum()
} else{
stop("Please enter a valid test.")
}
return(list(data_out, pchisq(q = data_out, df = df, lower.tail = FALSE)))
}
}
goodness_of_fit <- function(model, ..., response, type = "Chisq"){
# This function is designed to only work with contingency tables in the form of an array.
#
if(!is.null(model$data)){
data <- model$data
}
# If the inputed data is not an array, the function is exited, and an error message is displayed.
if(!is.data.frame(data)){
stop("Please enter a data frame")
} else{
# Number of combinations of the response variable - number of parameters in the model
df <-
(data %>%
select(-matches(response)) %>%
unique() %>%
tally() %>%
as.numeric()) - length(coef(model))
# Creates a data frame where the response column is converted into integers 0, 1, ...
data_response <-
data %>%
transmute_at(
vars(matches(response))
,unclass
) %>%
select(Response_Num = matches(response)) %>%
transmute(Response_Num = Response_Num - 1)
data_summary <-
data %>%
ungroup() %>%
# Combines the data with integer version of the Response
cbind(data_response) %>%
as_tibble() %>%
group_by_at(
vars(
colnames(data)[colnames(data) != response]
)
) %>%
# Summarizes by the 2 explanatory variables, and then finds the number of entries for each level of the Response
summarize(
Response_0 = sum(Response_Num)
,Response_1 = length(Response_Num) - Response_0
,Total = Response_1 + Response_0
) %>%
ungroup()
response_n_cols <- c("n", response)
data_out <-
data_summary %>%
cbind(
phat =
predict(
object = model
,newdata = data_summary
,type = "response"
)
) %>%
as_tibble() %>%
mutate(
Expected_0 = phat * Total
,Expected_1 = (1 - phat) * Total
)
if(type == "Chisq"){
data_out <-
data_out %>%
mutate(
ChiSq_0 = (Response_0 - Expected_0)^2 / Expected_0
,ChiSq_1 = (Response_1 - Expected_1)^2 / Expected_1
) %>%
select(
ChiSq_0
,ChiSq_1
) %>%
sum()
} else if(type == "Gsq"){
data_out <-
data_out %>%
mutate(
GSq_0 = 2 * Response_0 * log(Response_0 / Expected_0)
,GSq_1 = 2 * Response_1 * log(Response_1 / Expected_1)
) %>%
select(
GSq_0
,GSq_1
) %>%
sum()
} else{
stop("Please enter a valid test.")
}
return(list(data_out, pchisq(q = data_out, df = df, lower.tail = FALSE)))
}
}
goodness_of_fit(lung_logit,response = "Lung")
document()
library(flatr)
?goodness_of_fit
document()
library(flatr)
library(flatr)
?goodness_of_fit
